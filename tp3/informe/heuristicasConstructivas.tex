\chapter{Heuristicas Constructivas}

\section{Introduccíon}
Para enfrentar al problema de construir un dibujo incremental, pensamos varias heuristicas distintas.

A continuación se presentan las mismas, comentando las ideas sobre las que se basan, mostrando su aplicación a un grafo de ejemplo y el pseudocodigo de cada una.

Posteriormente se realiza un estudio empirico de ellas comparando su desempeño para minimizar el número de cruces, asi como el tiempo que necesitan para poder ejecutarse. A partir de estas experiencias seleccionamos una heuristica para su implementación definitiva en C++.

\section{Descripción de las heuristicas}

\subsection{Heuristica de inserción Greedy de nodos}
El primer enfoque que pensamos consiste en partir del dibujo original, es decir el que solo tiene los nodos cuyo orden esta
fijo e ir agregando los nuevos nodos con sus ejes, en la mejor posición en ese momento. Es decir, elegimos un nodo, y lo colocamos en la posición que genere menos cruces, teniendo en los nodos ya puestos.

Una vez hecho eso, se elige otro nodo (entre los que todavia no estan puestos) y se insertan en la misma manera.

La elección se va a haciendo para cada partición, es decir se toma primero un nodo de los que tienen que ir en la primer partición y se inserta, luego se toma otro de la segunda. Cuando ya se insertaron todos los nodos de una, se continua con los de la otra

Por como procede esta heuristica, si hay ejes a agregar que tienen sus dos extremos en nodos que ya estaban en el dibujo, lo que
hacemos es ponerlos al principio, antes de hacer nada, porque asi obtenemos mas información para insertar a los nuevos nodos.

Hay varias formas de elegir a que nodo insertar. Nosotros consideramos tres formas distintas:
\begin{enumerate}
\item Escoger un nodo al azar entre los libres
\item Escoger el nodo de mayor grado hacia el dibujo armado (es decir el nodo que tenga mas adyacentes ya colocados)
\item Escoger el nodo de menor grado hacia el dibujo armado (el nodo que tenga menos adyacentes ya colocados)
\end{enumerate}

Vamos a aplicar la heuristica al siguiente grafo:

\begin{figure}[H]
    \centering
    \setcounter{subfigure}{0}
    \subfigure[]{
     \includegraphics[scale=0.25]{./figuras/constructivas/insercionGreedyRandom/posta.png}}
     \subfigure[]{
\includegraphics[scale=0.25]{./figuras/constructivas/insercionGreedyRandom/dibujo0.png} }
     \caption{dibujo óptimo y dibujo de partida}       
      \label{fig:posta}
\end{figure} 

\begin{itemize}

\item Insercion por selección random
\begin{figure}[H]
\centering
\setcounter{subfigure}{0}
\subfigure[]{
\includegraphics[scale=0.2]{./figuras/constructivas/insercionGreedyRandom/dibujo1.png}}
\subfigure[]{
\includegraphics[scale=0.2]{./figuras/constructivas/insercionGreedyRandom/dibujo2.png} }
\subfigure[]{
\includegraphics[scale=0.2]{./figuras/constructivas/insercionGreedyRandom/dibujo3.png}}
\subfigure[]{
\includegraphics[scale=0.2]{./figuras/constructivas/insercionGreedyRandom/dibujo4.png}}
\end{figure}

\item Inserción tomando mayor grado

\begin{figure}[H]
\centering
\setcounter{subfigure}{0}
\subfigure[]{
\includegraphics[scale=0.2]{./figuras/constructivas/insercionGreedyMayorGrado/dibujo1.png}}
\subfigure[]{
\includegraphics[scale=0.2]{./figuras/constructivas/insercionGreedyMayorGrado/dibujo2.png} }
\subfigure[]{
\includegraphics[scale=0.2]{./figuras/constructivas/insercionGreedyMayorGrado/dibujo3.png}}
\subfigure[]{
\includegraphics[scale=0.2]{./figuras/constructivas/insercionGreedyMayorGrado/dibujo4.png}}
\end{figure}

\item Insercion por menor grado
\begin{figure}[H]
\centering
\setcounter{subfigure}{0}
\subfigure[]{
\includegraphics[scale=0.2]{./figuras/constructivas/insercionGreedyMenorGrado/dibujo1.png}}
\subfigure[]{
\includegraphics[scale=0.2]{./figuras/constructivas/insercionGreedyMenorGrado/dibujo2.png} }
\subfigure[]{
\includegraphics[scale=0.2]{./figuras/constructivas/insercionGreedyMenorGrado/dibujo3.png}}
\subfigure[]{
\includegraphics[scale=0.2]{./figuras/constructivas/insercionGreedyMenorGrado/dibujo4.png}}
\end{figure}
\end{itemize}

%TODO: ver que esto se respete o sino cambiarlo :p
\subsubsection{Pseudocodigo}
\begin{algorithm}[H]
\caption{Propone un dibujo mediante la inserción golosa de nodos}
\begin{algorithmic}[1]
\PARAMS{un dibujo original, los nodos a colocar, y los ejes entre los nodos}
\WHILE{Queden nodos por poner}
\FOR{cada particion, si es posible}
\STATE nodo $\leftarrow$ elegir uno entre los nodos a poner
\STATE sacar al nodo de entre los nodos a poner
\STATE colocar al nodo en la ultima posicion de su partición
\STATE cruces $\leftarrow$ cuantos cruces se agregan
\STATE mejorCruces $\leftarrow$ cruces
\STATE crucesPreSwap $\leftarrow$ cruces entre el nodo y el nodo anterior en la particion
\STATE mejorPos = ultima posicion
\WHILE{No revise todas las posiciones}
\STATE mover al nodo a la proxima posición \COMMENT{``swapear'' al nodo con el que esta en la posicion anterior}
\STATE crucesPostSwap $\leftarrow$ cruces entre el nodo y el nodo anterior en la particion
\STATE cruces $\leftarrow$ cruces - crucesPreSwap + crucesPostSwap
\IF{ cruces $<$ mejorCruces}
\STATE mejorCruces $\leftarrow$ cruces
\STATE mejorPos $\leftarrow$ la posicion donde esta ahora
\ENDIF
\STATE crucesPreSwap $\leftarrow$ crucesPostSwap
\ENDWHILE
\STATE poner al nodo finalmente en mejorPos
\ENDFOR
\ENDWHILE
\end{algorithmic}
\end{algorithm} 

\subsection{Heuristica de insercion Greedy por ejes}
Nuevamente partimos del dibujo original, pero esta vez vamos agregando ejes. Es decir tomamos un eje de los que vienen en el nuevo dibujo y lo agregamos poniendo a sus nodos en la posición que minimize el número de cruces. Si tomamos un eje que une dos nodos que no fueron puestos aun, se agregan ambos nodos y se prueban las distintas combinaciones para minimizar los cruces. Si alguno (o ambos extremos) ya estaban puestos, se sacan ambos y se reubican. 

Esta reubicación tiene mas información que la primera ubicación, ya que por lo menos ambos tienen un eje ya colocado, por lo que podr'ia mejorar incluso la cantidad de cruces que habia antes de agregar el eje, cosa que con la heuristica anterior no ocurre: en la heuristica de inserción de nodos, cada vez que se colocaba un nodo el número de cruces aumentaba o permanecía igual; pero nunca puede bajar.

Por otro lado, si bien parecería que puede lograr mejores resultados que la otra heuristica, hay que tener en cuenta que va a resultar mas costosa, ya que para cada eje hay que recorrer toda la primer partición, y para cada posición de esta, se recorre la segunda, viendo cuantos cruces se originan. Por esta razón, es importante analizar no solo el desempeño de esta heuristica en cuanto a reducir el número de cruces, sino también en cuanto al tiempo que demora, ya que podría ser considerablemente mas alto que el de las dem'as heuristicas.

Si aplicamos la heuristica para \ref{fig:posta}, obtenemos lo siguiente:

\begin{figure}[H]
\centering
\setcounter{subfigure}{0}
\subfigure[]{
\includegraphics[scale=0.2]{./figuras/constructivas/insercionEjes/dibujo1.png}}
\subfigure[]{
\includegraphics[scale=0.2]{./figuras/constructivas/insercionEjes/dibujo2.png} }
\subfigure[]{
\includegraphics[scale=0.2]{./figuras/constructivas/insercionEjes/dibujo3.png}}
\subfigure[]{
\includegraphics[scale=0.2]{./figuras/constructivas/insercionEjes/dibujo4.png}}
\end{figure}

Notemos como en el ultimo paso, agrega el eje (3,8) mueve al 8 de la posición que le habia asignado antes, de modo de reducir
la cantidad de cruces. Por otro lado notemos que si bien logro la solución óptima, esto se debió a que cuando podia elegir donde poner a los nodos, los puso abajo, si se hubiese elegido ponerlos arriba (opción valida, dado que genera la misma cantidad de cruces, es decir 0) el resultado hubiera sido distinto.

\subsubsection{Pseudocodigo}
\begin{algorithm}[H]
\caption{Propone un dibujo mediante la inserción golosa de ejes}
\begin{algorithmic}[1]
\STATE ejesPuestos $\leftarrow$ los ejes del dibujo original
\STATE puesto$[v_i]$ $\leftarrow$ si $v_i$ estaba en el dibujo original entonces True sino False
\FOR{cada eje(x,y) a agregar}
\IF{ya puse a x}
   \STATE sacarlo
\ELSE
   \STATE marcarlo como ya puesto
\ENDIF
\IF{ya puse a y}
   \STATE sacarlo
\ELSE
   \STATE marcarlo como ya puesto
\ENDIF
\STATE agregar el eje a los ejes Puestos 
\STATE agregar a x a la lista de adyacencia de y
\STATE agregar a y a la lista de adyacencia de x
\STATE calcular los rangos en los cuales puedo mover a $x$ y a $y$ \COMMENT{si alguno estaba en el dibujo original, hay que respetar el orden relativo}
\STATE insertar a x en su primer posición valida
\STATE insertar a y en su primer posición valida
\STATE mejoresCruces $\leftarrow$ los cruces por ponerlos en esta posición
\STATE mejorPosición $\leftarrow$ posición actual
\FOR{cada posicion valida para x}
\FOR{cada posición valida para y}
\STATE contar los cruces por dejarlos en esa posición
\IF{generan menos cruces que mejoresCruces}
   \STATE mejoresCruces $\leftarrow$ cruces por tenerlos en esta posicion
   \STATE mejorPosición $\leftarrow$ posicion actual
\ENDIF
\STATE mover y a su proxima posición
\ENDFOR
\STATE mover a x a su proxima posición
\STATE mover a y a su primer posición valida
\ENDFOR
\STATE mover a $x$ y a $y$ a la mejorPosicion
\ENDFOR
\end{algorithmic}
\end{algorithm} 

\subsection{Heuristica de construcción por mediana}
La idea de esta heuristica es buscar que ningún nodo este ``demasiado´´ lejos de sus adyacentes. Para lograr esto utilizamos la mediana de las posiciones de sus adyacentes.

El procedimiento es el siguiente, en un principio se comienza con solamente los nodos que ya estaban en el dibujo y sus ejes.

Tomamos entonces al nodo de mayor grado (con respecto a los nodos que ya estan puestos), calculamos la mediana de las posiciones de sus adyacentes y una vez que la obtenemos, probamos insertar al nodo en la posición de su mediana, o en la posición de su mediana mas o menos uno. Elegiendo de las tres la que genere menos cruces. En el caso en que la mediana no sea un indice valido, porque una partición tiene menos nodos y el valor de la mediana (que se calcula a partir de la posición de los nodos de la mas grande) supera a la cantidad de nodos de la misma, la truncamos. Repetimos el procedimiento hasta que esten puestos todos los nodos.

\begin{figure}[H]
\centering
\setcounter{subfigure}{0}
\includegraphics[scale=0.25]{./figuras/constructivas/medianaTruncada.png}
\caption{ejemplo de inserción por mediana con truncamiento}
\end{figure}

Al igual que en la heuristica de insercción de nodos, si habia ejes a agregar entre los nodos que ya estaban, estos se agregan al inicio para dar mas información a las posteriores inserciones.

Si aplicamos la heuristica a \ref{fig:posta} lo que se obtiene es, en este ejemplo, lo mismo que en la inserción greedy de nodos. Ya que siempre se agregan nodos que tienen un adyacente, el cual esta ubicado al final de la partición.

Esta heuristica utiliza un criterio greedy indirecto, es decir, las otras heuristicas son greedys en cuanto al número de cruces que se originan por cada insercion, en cambio esta es greedy en la distancia a la que queda cada nodo de sus adyacentes. Es una heuristica similar a la del baricentro, y que en el caso del problema de dibujo de grafos bipartitos sin la caracteristica de ser incrementales se muestra como una heuristica buena %TODO citar paper :p

Luego de ubicar a todos los nodos, se hace una pasada en cada partición intercambiando nodos en posiciones consecutivas si generan menos cruces, para de esta manera intentar reducir el efecto que puede tener el truncamiento de la mediana cuando todavia no estan todos los nodos puestos. Es decir, si un nodo se inserta en una partición con pocos nodos, y su mediana da muy alta, esta se trunca. Entonces queda con la misma mediana que otros nodos que tenian su mediana mas chica. Entonces en un intento de paliar esta situcación es que se intenta intercambiar posiciones consecutivas que generen menos cruces.

\subsubsection{Pseudocodigo}
\begin{algorithm}[H]
\caption{Propone un dibujo mediante la inserción por la mediana de los adyacentes}
\begin{algorithmic}[1]
\WHILE{queden nodos sin poner}
\STATE elegir un nodo de grado maximo con respecto a lo que ya esta puesto
\STATE calcular la mediana de las posiciones de sus adyacentes
\IF{mediana $>$ tamaño actual de la partición}
\STATE mediana $\leftarrow$ tamaño de la partición
\ENDIF
\FOR{ cada i = mediana-1,mediana,mediana+1}
\IF{es una posición valida}
\STATE contar los cruces por ponerlo en esa posición
\IF{lo inserte por primera vez o me genera menos cruces que la mejor posicion}
\STATE mejor posicion $\leftarrow$ posiciónActual
\ENDIF
\ENDIF
\ENDFOR
\STATE poner al nodo en la mejor posición de las 3
\ENDWHILE
\end{algorithmic}
\end{algorithm} 

\section{Comparación de las heuristicas constructivas}
A fin de decidir cual o cuales de estas heuristicas se comporta mejor, decidimos hacer primero una implementación en python, lenguaje que nos resulta mas comodo que C++ o Java. Utilizando estas implementaciones, aplicar las heuristicas y comparar los resultados, teniendo en cuenta no solo la cantidad de cruces, sino también el tiempo que le toma a cada una proponer un dibujo.

Lo que esperamos es que la heuristica de insercción de ejes de mejores resultados por el hecho de que reinserta nodos, por lo cual tiene varias oportunidades para fijarlos, por lo cual podría corregir errores cometidos por insertar cuando todavia habia pocos nodos puestos.

Sin embargo, creemos que este metodo puede ser considerablemente mas lento que los demas. Por un lado porque itera tantas veces como ejes se agreguen, lo cual podria $O(n^2)$ con n la cantidad de nodos. Ademas cada una de estas iteraciones requiere de $O(n^2)$ intercambio de nodos. Si a esto le sumamos el costo de contar los cruces vemos que el orden es bastante elevado.

Por otro lado no estamos seguros a priori de que resultados puede dar la heuristica de la mediana, ya que calcular la mediana cuando todavia no esta fija ninguna de las particiones podría no brindar suficiente información. Sin embargo, creemos que va a ser el método mas rapido, ya que para cada nodo solo hace a lo sumo tres intentos de inserción.

Finalmente con respecto a la inserción golosa de los nodos, creemos que su costo será menor que el de la inserción de ejes, pero sus resultados podrian no ser tan buenos.

Para probarlos corrimos los siguientes tests:
\begin{enumerate}
\item Comparación de Heuristicas de inserción golosa de nodos:
Primero comparamos a las diferentes formas de elegir al nodo candidato, para observar si alguna de las formas de hacerlo, se desempeñaba mejor.

\item Comparación entre Heuristicas
\begin{enumerate}
\item n nodos en cada partición con n creciente. Cantidad de ejes = $\frac{n^2}{2}$. Porcentaje de nodos nuevos: 60\%
\item n nodos en cada partición con n creciente. Cantidad de ejes = $\frac{n^2}{2}$. Porcentaje de nodos nuevos: 40\%
\item n nodos en cada partición con n creciente. Cantidad de ejes = 3n. Porcentaje de nodos nuevos: 60\%
\item n nodos en cada partición con n creciente. Cantidad de ejes = 3n. Porcentaje de nodos nuevos: 40\%
%\item n = 30. Cantidad de ejes creciente. Porcentaje de nodos nuevos: 60%
\item n = 30. Cantidad de ejes creciente. Porcentaje de nodos nuevos: 40\%
\end{enumerate}
\end{enumerate}

En cada uno de ellos, se midió la cantidad de cruces y el tiempo utilizado para lograr el dibujo.

Si bien consideramos que los tiempos de ejecución en un lenguaje interpretado como lo es Python, son por lo general mayores que los tiempos de ejecución en C++, creemos que son igualmente validos para permitirnos observar una tendencia general en el comportamiento de las heuristicas. Por otro lado, dado que implementar en este lenguaje nos resulta mucho mas sencillo, consideramos que vale la pena probar a las tres heuristicas en vez de simplemente proponer una unica para implementar en C++.

\subsection{Criterios de selección de nodos para la heuristica de inserción de nodos}
Las pruebas que realizamos consistieron en aplicar la heuristica de insercion de nodos a grafos aleatorios variando la cantidad de nodos en cada partición.

En la primer experiencia utilizamos grafos con $m=2*n$ y un $40\%$ de nodos fijos (En adelante n es la cantidad de nodos de cada partición).

En la segunda experiencia la cantidad de ejes estaba dada por $m=\frac{n^2}{2}$ y el porcentaje de nodos fijos fue también del $40\%$.

La idea fue observar si alguno de los criterios para elegir que nodo insertar en cada paso lograba un mejor desempeño.

Los resultados se encuantran en los graficos 

\begin{figure}[H]
\centering
\setcounter{subfigure}{0}
\subfigure[]{
\includegraphics[scale=0.6]{./graficos/comparacionInsercionNodos/exp2.png}}
\subfigure[]{
\includegraphics[scale=0.6]{./graficos/comparacionInsercionNodos/exp1.png}} 
\end{figure}

De estas experiencias, notamos que la cantidad de cruces encontrada por los tres metodos, es relativamente similar. Sin embargo lo que notamos es que el criterio de mayor grado parecería comportarse ligeramente mejor que los otros dos. Para nosotros tiene sentido que esto sea así, ya que si se utiliza el nodo de mayor grado con respecto a lo que ya esta puesto, ese nodo tiene mas información (mas adyacentes puestos) por lo que puede ubicarse mejor. Claro esta que esto podría fallar, sin embargo a partir de esta idea, mas lo que se observa en las pruebas, decidimos utilizar al nodo de mayor grado para la heuristica de inserción de nodos.

\subsection{Comparación de heuristicas constructivas}
Los resultados de las pruebas realizadas son los siguientes:

\begin{figure}[H]
\centering
\setcounter{subfigure}{0}
\subfigure[Cantidad de cruces producidos en funcion de n]{
\includegraphics[scale=0.61]{./graficos/comparacionConstructivas/cruces1.png}}
\setcounter{subfigure}{1}
\subfigure[Tiempo en segundos en función de n]{
\includegraphics[scale=0.61]{./graficos/comparacionConstructivas/tiempos1.png} }
\caption{n nodos en cada partición con n creciente. Cantidad de ejes = $\frac{n^2}{2}$. Porcentaje de nodos nuevos: 60\%}
\end{figure}

\begin{figure}[H]
\centering
\setcounter{subfigure}{0}
\subfigure[Cantidad de cruces producidos en funcion de n]{
\includegraphics[scale=0.61]{./graficos/comparacionConstructivas/cruces2.png}}
\setcounter{subfigure}{1}
\subfigure[Tiempo en segundos en función de n]{
\includegraphics[scale=0.61]{./graficos/comparacionConstructivas/tiempos2.png} }
\caption{{ n nodos en cada partición con n creciente. Cantidad de ejes = $\frac{n^2}{2}$. Porcentaje de nodos nuevos: 40\%}}
\end{figure}

\begin{figure}[H]
\centering
\setcounter{subfigure}{0}
\subfigure[Cantidad de cruces producidos en funcion de n]{
\includegraphics[scale=0.61]{./graficos/comparacionConstructivas/cruces3.png}}
\setcounter{subfigure}{1}
\subfigure[Tiempo en segundos en función de n]{
\includegraphics[scale=0.61]{./graficos/comparacionConstructivas/tiempos3.png} }
\caption{ n nodos en cada partición con n creciente. Cantidad de ejes = 3n. Porcentaje de nodos nuevos: 60\%}
\end{figure}

\begin{figure}[H]
\centering
\setcounter{subfigure}{0}
\subfigure[Cantidad de cruces producidos en funcion de n]{
\includegraphics[scale=0.61]{./graficos/comparacionConstructivas/cruces4.png}}
\setcounter{subfigure}{1}
\subfigure[Tiempo en segundos en función de n]{
\includegraphics[scale=0.61]{./graficos/comparacionConstructivas/tiempos4.png} }
\caption{ n nodos en cada partición con n creciente. Cantidad de ejes = 3n. Porcentaje de nodos nuevos: 40\%}
\end{figure}

\begin{figure}[H]
\centering
\subfigure[Cantidad de cruces producidos en funcion de m]{
\includegraphics[scale=0.61]{./graficos/comparacionConstructivas/cruces5.png}}
\subfigure[Tiempo en segundos en función de m]{
\includegraphics[scale=0.61]{./graficos/comparacionConstructivas/tiempos5.png} }
\caption{ n = 30. Cantidad de ejes creciente. Porcentaje de nodos nuevos: 40\%}
\setcounter{subfigure}{0}
\end{figure}

\section{Análisis de los resultados}
Al observar los gr'aficos de las experiencias lo primero que salta a la vista es que el tiempo de ejecución de la heur'istica de inserción de ejes es mucho mas grande que el de las demas. Esta situación que se hace mas notoria en grafos densos hace que su uso no sea recomendable, mas si tenemos en cuenta a partir de las demas experiencias, que los resultados que obtiene no son significativamente mejores que el del resto de las heuristicas. Por ejemplo, en la experiencia 5 vemos como para un grafo con 30 nodos y 799 ejes la diferencia entre la inserción de nodos y la inserción de ejes de 442 cruces a favor de la insercióon de ejes (142131 contra 141689), lo cual representa una diferencia del 0.3120 \%, pero en cuanto a tiempos para la misma instancia, insercion de nodos demoró 0.5160 segundos contra 13.6870 que demoró la inserción de ejes, es decir 26.5252 veces mas.

Por esta razón, si bien en general vemos que da resultados relativamente buenos, decidimos descartarla.

Por otro lado, la heuristica de la mediana se muestra como la mas rapida, suponemos que debido a que la cantidad de veces que necesita contar cruces, ya sea entre dos nodos o en todo el grafo, es mucho menor que la de las otras. Sin embargo, en cuanto a la cantidad de cruces, suele dar peores resultados que las otras dos. Es por esto, que decimos descartar también esta heuristica también.

De esta manera elegimos implementar en C++ la heuristica de inserción de nodos, ya que consideramos que de las tres alternativas planteadas es la que brinda resultados bastante buenos (comparada con las demas heuristicas planteadas) en tiempos razonables. 

%es un buen momento para comentar la estructura que se utilizo 
\section{Detalles de implementación de la heuristica constructiva}

%darle rigurosidad al pseudocodigo correspondiente para poder usarlo aca
\section{Calculo de complejidad}

\section{Analisis experimental}
\subsection{Tiempo de ejecución}

\subsection{Casos borde}

\section{Discusión}